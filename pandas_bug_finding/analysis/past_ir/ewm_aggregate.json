{
  "metadata": {
    "function": "pd.DataFrame.ewm.aggregate",
    "library": "pandas",
    "version": "3.0.0",
    "signature": "ExponentialMovingWindow.aggregate(func=None, *args, **kwargs)"
  },
  "logical_errors": [
    {
      "id": "E1",
      "description": "The docstring states 'scalar: when Series.agg is called with single function'. This is incorrect for EWM. Because EWM is a window operation, calling aggregate with a single function on an EWM Series returns a Series of the same length as the input (each element is the EWM result up to that point), never a scalar.",
      "severity": "severe",
      "source": "user-provided docstring — Returns section",
      "affects_properties": []
    },
    {
      "id": "E2",
      "description": "The docstring states 'Series: when DataFrame.agg is called with a single function'. This is incorrect for EWM. Calling aggregate with a single function on an EWM DataFrame returns a DataFrame of the same shape as the input, not a Series. The return type description was likely copied verbatim from the non-windowed DataFrame.agg docstring without adapting it for the window semantics.",
      "severity": "severe",
      "source": "user-provided docstring — Returns section",
      "affects_properties": []
    },
    {
      "id": "E3",
      "description": "The example in the aggregate docstring shows df.ewm(alpha=0.5).mean(), which calls the .mean() method directly, not .aggregate() or its alias .agg(). This example does not demonstrate any usage of the aggregate interface.",
      "severity": "minor",
      "source": "user-provided docstring — Examples section",
      "affects_properties": []
    }
  ],
  "input_domain": {
    "self": "ExponentialMovingWindow object, constructed via DataFrame.ewm() or Series.ewm()",
    "ewm_configuration": {
      "decay_param": "exactly one of com (>= 0), span (>= 1), halflife (> 0), or alpha (0 < alpha <= 1) must be provided when times is not used",
      "min_periods": "int >= 0, default 0; minimum observations required to produce a non-NaN result",
      "adjust": "bool, default True; when True applies decaying adjustment factor for early-period imbalance",
      "ignore_na": "bool, default False; when True ignores NaN values in weight calculations"
    },
    "func": "one of: callable, string function name, list of callables and/or strings, or dict mapping column labels to functions/strings/lists",
    "args": "positional arguments forwarded to func (only applicable when func is callable)",
    "kwargs": "keyword arguments forwarded to func (only applicable when func is callable)",
    "constraints": [
      "func must not be None (behavior is undefined per ambiguity A1)",
      "func as dict — keys must be column labels present in the calling DataFrame/Series",
      "mutating functions are explicitly not supported and are excluded from the input domain"
    ],
    "invalid_inputs": [
      "func as an unrecognized string name (e.g. 'invalid_func') — raises AttributeError or similar",
      "func as dict with keys not present in the DataFrame columns — raises KeyError or similar",
      "mutating UDFs — undefined behavior per docstring warning"
    ]
  },
  "properties": [
    {
      "id": "P1",
      "type": "explicit",
      "claim": "agg is an alias for aggregate and produces identical results for all valid inputs",
      "expression": "pd.testing.assert_frame_equal(df.ewm(alpha=a).agg(func), df.ewm(alpha=a).aggregate(func))",
      "when": "any valid func (string, callable, list, dict), any valid ewm configuration",
      "strategy": "generate numeric DataFrames of various shapes and dtypes, construct EWM with randomly drawn valid alpha or com values, call both .agg(func) and .aggregate(func) with the same func argument (string 'mean', callable, and list ['mean', 'std']), assert results are equal using pd.testing.assert_frame_equal",
      "source": "user-provided docstring — Notes section: 'agg is an alias for aggregate. Use the alias.'"
    },
    {
      "id": "P2",
      "type": "explicit",
      "claim": "DataFrame.aggregate with several functions returns a DataFrame",
      "expression": "isinstance(df.ewm(alpha=a).aggregate([f1, f2]), pd.DataFrame)",
      "when": "func is a list of 2 or more valid EWM-compatible function strings, called on a DataFrame EWM object",
      "strategy": "generate numeric DataFrames with at least one column, construct EWM with valid decay parameters, call .aggregate(['mean', 'std']), assert the result is an instance of pd.DataFrame",
      "source": "user-provided docstring — Returns section: 'DataFrame: when DataFrame.agg is called with several functions'"
    },
    {
      "id": "P3",
      "type": "explicit",
      "claim": "A user-defined function passed to aggregate receives a Series for evaluation",
      "expression": "all(isinstance(arg, pd.Series) for arg in captured_args)",
      "when": "func is a callable (UDF), called on a DataFrame EWM object",
      "strategy": "define a UDF that appends type(arg) to an external list before returning arg.mean(), call df.ewm(alpha=0.5).aggregate(udf) on a multi-column DataFrame, assert every captured argument type is pd.Series",
      "source": "user-provided docstring — Notes section: 'A passed user-defined-function will be passed a Series for evaluation.'"
    },
    {
      "id": "P4",
      "type": "implicit",
      "claim": "Calling aggregate with a single function on an EWM DataFrame returns a DataFrame (not a Series as the docstring incorrectly states)",
      "expression": "isinstance(df.ewm(alpha=a).aggregate('mean'), pd.DataFrame)",
      "when": "func is a single string or callable, called on a DataFrame EWM object",
      "strategy": "generate numeric DataFrames of various shapes, construct EWM with valid alpha/com, call .aggregate('mean') and .aggregate(np.mean-compatible callable), assert each result is an instance of pd.DataFrame",
      "source": null
    },
    {
      "id": "P5",
      "type": "implicit",
      "claim": "Calling aggregate with a single function on an EWM Series returns a Series (not a scalar as the docstring incorrectly states)",
      "expression": "isinstance(series.ewm(alpha=a).aggregate('mean'), pd.Series)",
      "when": "func is a single string or callable, called on a Series EWM object",
      "strategy": "generate numeric Series of various lengths, construct EWM with valid alpha/com, call .aggregate('mean'), assert the result is an instance of pd.Series",
      "source": null
    },
    {
      "id": "P6",
      "type": "implicit",
      "claim": "aggregate does not mutate the original DataFrame",
      "expression": "df_before.equals(df_after) where df_after is checked after calling df.ewm(alpha=a).aggregate(func)",
      "when": "any valid non-mutating func, any valid ewm configuration",
      "strategy": "generate a numeric DataFrame, capture a deep copy before calling .ewm(alpha=a).aggregate('mean'), compare the original to the copy using pd.testing.assert_frame_equal after the call completes",
      "source": null
    },
    {
      "id": "P7",
      "type": "implicit",
      "claim": "aggregate is deterministic — identical inputs and EWM configuration always produce identical outputs",
      "expression": "pd.testing.assert_frame_equal(result1, result2)",
      "when": "any valid func, any valid ewm configuration, no random state in func",
      "strategy": "generate a numeric DataFrame, call .ewm(alpha=a).aggregate('mean') twice with exactly the same EWM parameters, assert both results are equal using pd.testing.assert_frame_equal",
      "source": null
    },
    {
      "id": "P8",
      "type": "implicit",
      "claim": "Result row count equals input DataFrame row count when applying a single function",
      "expression": "len(df.ewm(alpha=a).aggregate('mean')) == len(df)",
      "when": "func is a single string or callable, called on a DataFrame EWM object",
      "strategy": "generate DataFrames of various lengths including length 1 and lengths > 10, call .ewm(alpha=a).aggregate('mean'), assert len(result) == len(df)",
      "source": null
    },
    {
      "id": "P9",
      "type": "implicit",
      "claim": "Result column names match input DataFrame column names when applying a single function",
      "expression": "list(df.ewm(alpha=a).aggregate('mean').columns) == list(df.columns)",
      "when": "func is a single string or callable, called on a DataFrame EWM object",
      "strategy": "generate DataFrames with various column name configurations (string names, integer names, mixed types), call .ewm(alpha=a).aggregate('mean'), assert result.columns equals df.columns",
      "source": null
    },
    {
      "id": "P10",
      "type": "implicit",
      "claim": "With min_periods=0 (default), aggregate produces non-NaN output for the first row when input has no NaN values",
      "expression": "result.iloc[0].notna().all()",
      "when": "func='mean', min_periods=0 (default), input DataFrame has no NaN values, at least one row",
      "strategy": "generate numeric DataFrames with no NaN values and at least one row, call .ewm(alpha=a).aggregate('mean') with default min_periods=0, assert the first row of the result has no NaN values",
      "source": "fetched online documentation — Parameter min_periods: 'Minimum number of observations in window required to have a value; otherwise result is np.nan'"
    },
    {
      "id": "P11",
      "type": "indirect",
      "claim": "When func is a list of functions, the result has a MultiIndex column where one level contains the function names",
      "expression": "isinstance(result.columns, pd.MultiIndex) and set(result.columns.get_level_values(-1)) == {'mean', 'std'}",
      "when": "func=['mean', 'std'], called on a multi-column DataFrame EWM object",
      "strategy": "generate a multi-column numeric DataFrame, call .ewm(alpha=a).aggregate(['mean', 'std']), assert result.columns is a MultiIndex and the innermost level contains exactly the strings 'mean' and 'std'",
      "source": "user-provided docstring — Parameters: 'list of functions and/or function names, e.g. [np.sum, \"mean\"]'"
    },
    {
      "id": "P12",
      "type": "indirect",
      "claim": "When func is a dict mapping column labels to functions, each column is aggregated by its assigned function independently",
      "expression": "pd.testing.assert_series_equal(result['A'], df.ewm(alpha=a).aggregate('mean')['A']) and pd.testing.assert_series_equal(result['B'], df.ewm(alpha=a).aggregate('std')['B'])",
      "when": "func={'A': 'mean', 'B': 'std'}, DataFrame has columns 'A' and 'B', called on a DataFrame EWM object",
      "strategy": "generate a two-column numeric DataFrame with columns named 'A' and 'B', call .ewm(alpha=a).aggregate({'A': 'mean', 'B': 'std'}), compare result column 'A' against .ewm(alpha=a).aggregate('mean')['A'] and result column 'B' against .ewm(alpha=a).aggregate('std')['B'] using pd.testing.assert_series_equal",
      "source": "user-provided docstring — Parameters: 'dict of axis labels -> functions, function names or list of such'"
    },
    {
      "id": "P13",
      "type": "indirect",
      "claim": "Mathematically equivalent decay parameterizations (com vs alpha) produce identical aggregate results",
      "expression": "pd.testing.assert_frame_equal(df.ewm(com=c).aggregate('mean'), df.ewm(alpha=1/(1+c)).aggregate('mean'), check_exact=False, rtol=1e-10)",
      "when": "func='mean', com >= 0, using alpha = 1/(1+com) as the equivalent parameterization",
      "strategy": "draw com values in [0, 10], compute equivalent alpha = 1.0 / (1.0 + com), generate a numeric DataFrame, call .ewm(com=com).aggregate('mean') and .ewm(alpha=alpha).aggregate('mean'), assert both results are numerically equal using pd.testing.assert_frame_equal with check_exact=False and rtol=1e-10",
      "source": "fetched online documentation — Parameters: 'com: α = 1 / (1 + com), for com ≥ 0' and 'alpha: Specify smoothing factor α directly, 0 < α ≤ 1'"
    }
  ],
  "unresolved_ambiguities": [
    {
      "id": "A1",
      "description": "func=None behavior is not documented. The default signature is func=None but neither the docstring nor the online documentation specifies what happens when aggregate is called with no arguments or func=None explicitly.",
      "source": "user-provided docstring — function signature: func=None as default",
      "maintainer_note": "What is the intended behavior when func=None? Does it raise TypeError, return a no-op, or invoke a default aggregation?"
    },
    {
      "id": "A2",
      "description": "The set of valid string function names for EWM aggregate is not enumerated. The EWM object exposes .mean(), .std(), .var(), .sum(), .corr(), .cov() as methods, but it is unclear which of these (or others) are accepted as string names and which strings cause an error.",
      "source": "user-provided docstring — Parameters: 'string function name' with no enumeration of valid names",
      "maintainer_note": "Document which string names are valid for EWM.aggregate(). Are all EWM method names (mean, std, var, sum, corr, cov) valid strings? What about generic pandas aggregations like 'max', 'min', 'count'? What exception type is raised for invalid strings?"
    },
    {
      "id": "A3",
      "description": "Behavior of *args and **kwargs when func is a string function name (e.g. 'mean') is unspecified. It is unclear whether positional and keyword arguments are forwarded to the resolved EWM method or silently ignored.",
      "source": "user-provided docstring — Parameters: '*args' and '**kwargs'",
      "maintainer_note": "When func='mean' and additional args/kwargs are passed, are they forwarded to ewm.mean()? Document forwarding behavior for each func type (callable vs string vs list vs dict)."
    },
    {
      "id": "A4",
      "description": "The 'index relabeling' note ('If func defines an index relabeling, axis must be 0 or index') is unexplained in the EWM context. It is unclear what EWM-compatible index relabeling means or what functions could trigger this constraint.",
      "source": "user-provided docstring — Notes section",
      "maintainer_note": "What constitutes 'index relabeling' in the EWM context? This note appears inherited from the general resample/agg interface and may not apply to EWM at all."
    },
    {
      "id": "A5",
      "description": "The Notes section states 'aggregation operations are always performed over an axis, either the index (default) or the column axis', implying column-axis aggregation is possible. However, EWM is inherently a time-series window operation over the index axis and it is unclear if column-axis operations are supported or what they would mean.",
      "source": "user-provided docstring — Notes section",
      "maintainer_note": "Does EWM.aggregate() support column-axis (axis=1) operations? This note appears inherited from the general agg interface. If not supported, the note is misleading for EWM users."
    }
  ]
}
